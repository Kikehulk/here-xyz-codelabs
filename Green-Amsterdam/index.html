
<!doctype html>

<html>
<head>
  <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">
  <meta name="theme-color" content="#4F7DC9">
  <meta charset="UTF-8">
  <title>Make a map with Tangram and the XYZ API</title>
  <script src="../../bower_components/webcomponentsjs/webcomponents-lite.js"></script>
  <link rel="import" href="../../elements/codelab.html">
  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Source+Code+Pro:400|Roboto:400,300,400italic,500,700|Roboto+Mono">
  <style is="custom-style">
    body {
      font-family: "Roboto",sans-serif;
      background: var(--google-codelab-background, #F8F9FA);
    }
  </style>
  
</head>
<body unresolved class="fullbleed">

  <google-codelab title="Make a map with Tangram and the XYZ API"
                  environment="web"
                  feedback-link="https://github.com/here-xyz-codelabs/here-xyz-codelabs.github.io/issues">
    
      <google-codelab-step label="Introduction" duration="0">
        <p>This tutorial shows you how to create a Tangram map using data from XYZ Spaces. Tangram can display vector data and handle many more points than Leaflet alone.</p>
<h2 class="checklist">What you&#39;ll learn</h2>
<ul class="checklist">
<li>The basics of managing multiple XYZ spaces</li>
<li>The fundamentals of using tiled data</li>
<li>How to view your data in Tangram, using the tiled data endpoint</li>
<li>How to query data from XYZ using bounding box queries.</li>
</ul>
<h2>Prerequisites</h2>
<ul>
<li>Basic familiarity with the command line</li>
<li>Basic familiarity with JavaScript</li>
</ul>
<p>In this demo we&#39;ll download several public datasets for the city of Amsterdam and combine them in various ways in an interactive map.</p>
<p><img alt="Finished Amsterdam solar panels and tree map" src="img/fa42ea027b2d5928.png"></p>


      </google-codelab-step>
    
      <google-codelab-step label="Get the data" duration="10">
        <p>In this demo, we&#39;ll use open data provided by the City of Amsterdam. We&#39;ll look at two sources of data: solar panel installations, and street trees.</p>
<p>The solar data is available <a href="https://maps.amsterdam.nl/open_geodata/geojson.php?KAARTLAAG=ZONNEPANELEN2017&THEMA=zonnepanelen" target="_blank">to download</a>, but the default visualization of the data is not particularly informative.</p>
<p><img alt="Solar data" src="img/32522d6cad32930c.png"></p>
<p>Let&#39;s also download <a href="https://maps.amsterdam.nl/open_geodata/geojson.php?KAARTLAAG=BOMEN&THEMA=bomen1" target="_blank">some tree data</a> and upload both to their own XYZ spaces.</p>
<p>Create a space for the solar panels (&#34;zonnepanelen&#34; in Dutch) and the tree data (&#34;bomen&#34;):</p>
<pre><code>here xyz create --title &#34;solar panels&#34; --message &#34;Amsterdam solar panels&#34;
here xyz create --title &#34;trees&#34; --message &#34;Amsterdam trees&#34;
</code></pre>
<p>Throughout this tutorial whenever you see <code>SpaceID1</code> or <code>SpaceID2</code>, replace these with the Space IDs generated by those <code>create</code> commands.</p>
<p>Now upload the data to those two spaces:</p>
<pre><code>here xyz upload -f ZONNEPANELEN2017.json [SpaceID1]
here xyz upload -f BOMEN.json [SpaceID2]
</code></pre>
<p>To make the solar panel data more interpretable, let&#39;s try aggregating solar installations at the neighborhood level. To do so, we&#39;ll also need a <a href="https://maps.amsterdam.nl/open_geodata/geojson.php?KAARTLAAG=GEBIED_BUURTCOMBINATIES_EXWATER&THEMA=gebiedsindeling" target="_blank">dataset of Amsterdam neighborhood boundaries</a>.</p>
<p><img alt="Neighborhood boundaries" src="img/4614cdd4512e2679.png"></p>
<p>We won&#39;t upload that to a space yet. We&#39;re going to combine it with the solar data first.</p>


      </google-codelab-step>
    
      <google-codelab-step label="Preprocessing" duration="10">
        <p>We&#39;ll write a node script to find the total solar power generated in each neighborhood and save it to a new GeoJSON file, using <a href="http://turfjs.org/" target="_blank">turf</a>.</p>
<pre><code>    const fs = require(&#39;fs&#39;);
    const turf = require(&#39;@turf/turf&#39;);
    
    const NEIGHBORHOODS_FILE = &#39;./GEBIED_BUURTCOMBINATIES_EXWATER.json&#39;;
    const SOLAR_FILE = &#39;./ZONNEPANELEN2017.json&#39;;
    const OUT_FILE = &#39;./heatmap.json&#39;;
    
    var nhoods = JSON.parse(fs.readFileSync(NEIGHBORHOODS_FILE, {encoding: &#39;utf8&#39;}));
    var solar = JSON.parse(fs.readFileSync(SOLAR_FILE, {encoding: &#39;utf8&#39;}));
    
    nhoods.features.forEach(function(feature) {
        // get list of solar panels within neighborhood polygon
        var points = turf.pointsWithinPolygon(solar, feature)

        // add total number of panels as property to neighborhood
        feature.properties.count = points.features.length;

        // add total power generated as property to neighborhood
        feature.properties.totalPower = 0;
        points.features.forEach(function(point) {
            feature.properties.totalPower += +point.properties.Vermogen;
        });
    });
    
    fs.writeFileSync(OUT_FILE, JSON.stringify(nhoods), {encoding: &#39;utf8&#39;})
    
</code></pre>
<p>After installing turf with <code>npm install @turf/turf</code>, we can run this preprocessing script with <code>node process.js</code>, which will generate a file named <code>heatmap.json</code>. Finally, let&#39;s upload this to an XYZ space. This will be your third space, which we will call <code>SpaceID3</code>.</p>
<pre><code>here xyz create --title &#34;heatmap&#34; --message &#34;Neighborhood heatmap of solar power production&#34;
here xyz upload -f heatmap.json [SpaceID3]
</code></pre>
<p><img alt="heatmap upload" src="img/816fefa77738dedb.png"></p>


      </google-codelab-step>
    
      <google-codelab-step label="View the tiled data in Tangram" duration="10">
        <p>The XYZ API supports <em>tiling</em> vector data, which lets us only load the data in chunks so that we only get the data that we need to display at that moment. To use this tiled endpoint, we need a map client that supports tiling. We&#39;ll use <a href="https://github.com/tangrams/tangram" target="_blank">Tangram</a>, an open-source WebGL based map viewer.</p>
<p>First, we&#39;ll create a boilerplate Tangram map, just like <a href="https://here-xyz-codelabs.github.io/Air-Quality-In-Madrid/#0" target="_blank">we did with Leaflet</a>. The HTML for our map looks like this. Notice that we are creating a Leaflet map in much the same way as we did previously, but we are adding a <em>Tangram</em> layer to it.</p>
<aside class="special"><p>Note: This code snippet includes a bunch of CSS that we will use later. We won&#39;t explain most of it in this tutorial. If you&#39;re curious about CSS, there are tons of resources online to learn more.</p>
</aside>
<pre><code>&lt;!doctype html&gt;
&lt;html lang=&#34;en-us&#34;&gt;
  &lt;head&gt;
    &lt;meta charset=&#34;utf-8&#34;&gt;
    &lt;meta http-equiv=&#34;Content-Type&#34; content=&#34;text/html; charset=utf-8&#34;&gt;
    &lt;meta name=&#34;viewport&#34; content=&#34;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no&#34;&gt;
    &lt;title&gt;Amsterdam Solar Energy&lt;/title&gt;
    &lt;link rel=&#34;stylesheet&#34; href=&#34;https://unpkg.com/leaflet@1.3.3/dist/leaflet.css&#34; /&gt;
    &lt;link rel=&#34;stylesheet&#34; href=&#34;leaflet-areaselect.css&#34; /&gt;

    &lt;style&gt;
        body {
            margin: 0px;
            border: 0px;
            padding: 0px;
            font-family: Helvetica, Arial, sans-serif;
        }
        .container {
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            position: absolute;
        }
        #map {
            height: 100%;
            width: 100%;
        }
        #controls {
            position: absolute;
            left: 1em;
            top: 100px;
            z-index: 1000;
            background-color: rgba(200, 200, 200, 0.75);
            /* display: none; */
            width: 200px;
            height: 230px;
            border-radius: 6px;
        }
        #controls div {
            margin: 16px;
            padding: 0.5em;
            background-color: hsl(204, 100%, 72%);
            border: 1px solid black;
            border-radius: 3px;
            color: black;
            box-shadow: 2px 2px 2px black;
        }
        #controls div.off {
            background-color: hsl(204, 50%, 72%);
            color: gray;
        }
        #controls div:hover {
            background-color: dodgerblue;
            margin-top: 16px;
            margin-bottom: 16px;
            color: white;
            box-shadow: 4px 4px 4px black;
        }
        #controls div#counttrees {
            background-color: #228800;
            color: white;
        }
        #controls div#counttrees:hover {
            background-color: #44AA00;
            box-shadow: 4px 4px 4px black;
        }
    &lt;/style&gt;
  &lt;/head&gt;

  &lt;body&gt;
    &lt;div class=&#34;container&#34;&gt;
        &lt;div id=&#34;map&#34;&gt;&lt;/div&gt;
    &lt;/div&gt;


    &lt;!-- leaflet --&gt;
    &lt;script src=&#34;https://unpkg.com/leaflet@1.3.3/dist/leaflet.js&#34;&gt;&lt;/script&gt;

    &lt;!-- Main tangram library --&gt;
    &lt;script src=&#34;https://unpkg.com/tangram/dist/tangram.min.js&#34;&gt;&lt;/script&gt;

    &lt;!-- Demo setup --&gt;
    &lt;script&gt;
        var map = L.map(&#39;map&#39;, {boxZoom: false});
        var layer = Tangram.leafletLayer({
            scene: &#39;scene.yaml&#39;,
            attribution: &#39;&lt;a href=&#34;https://mapzen.com/tangram&#34; target=&#34;_blank&#34;&gt;Tangram&lt;/a&gt; | &amp;copy; OSM contributors | &lt;a href=&#34;https://mapzen.com/&#34; target=&#34;_blank&#34;&gt;Mapzen&lt;/a&gt;&#39;
        });
        layer.addTo(map);
        // center of amsterdam
        map.setView([52.372548, 4.893920], 12);
    &lt;/script&gt;

  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>This Tangram layer loads and styles <em>vector</em> data sources, which are defined in a seperate &#34;scene&#34; file, <code>scene.yaml</code> in this case.</p>
<p>Create a <code>scene.yaml</code> file, and add these lines:</p>
<pre><code>import:
    - https://www.nextzen.org/carto/refill-style/refill-style.zip
    - https://s3.amazonaws.com/xyz-demo/data/demo.yaml
    - https://www.nextzen.org/carto/refill-style/themes/label-5.zip
</code></pre>
<p>Those <code>import</code> statements will load a some external stylesheets data that will make up the background of our Tangram map.</p>
<p>To load our own XYZ data on top of this map, we&#39;ll need to add a <code>source</code> to our scene file for each dataset. The tiled endpoint has this format: <code>https://xyz.api.here.com/hub/spaces/[SpaceID]/tile/web/{z}_{x}_{y}</code>.</p>
<p>You will also need to provide an AccessToken.</p>
<aside class="special"><p>Remember that you can get an access token by running <code>here xyz show -w [spaceID]</code> and copying the AccessToken from the generated URL. Alternatively, you can create new tokens with specific permissions using the Token UI: <a href="https://xyz.api.here.com/token-ui/" target="_blank">https://xyz.api.here.com/token-ui/</a></p>
</aside>
<p>Add these lines to your <code>scene.yaml</code> file, replacing the Space IDs and your AccessToken:</p>
<pre><code>sources:
    solar:
        url: https://xyz.api.here.com/hub/spaces/[SpaceID1]/tile/web/{z}_{x}_{y}
        url_params:
            access_token: [AccessToken]
            clip: true
        type: GeoJSON
    neighborhoods:
        url: https://xyz.api.here.com/hub/spaces/[SpaceID3]/tile/web/{z}_{x}_{y}
        url_params:
            access_token: [AccessToken]
            clip: true
        type: GeoJSON
    trees:
        url: https://xyz.api.here.com/hub/spaces/[SpaceID2]/tile/web/{z}_{x}_{y}
        url_params:
            access_token: [AccessToken]
            clip: true
        type: GeoJSON
</code></pre>
<p>Now that we&#39;ve loaded those data sources, we need to instruct Tangram to draw some of them on the map. Let&#39;s draw the solar data by adding a new &#34;layer&#34; to <code>scene.yaml</code>:</p>
<pre><code>layers:
    _solar:
        data: {source: solar}
        enabled: true
        _all:
            draw:
                points:
                    collide: false
                    color: &#34;#000000&#34;
                    size: 5
</code></pre>
<p>Putting the HTML file and <code>scene.yaml</code> in the same folder lets us open up our <a href="https://stamen.github.io/here-xyz-demo/solar-tangram/index-step1.html" target="_blank">basic map</a>!</p>
<p><img alt="Basic map screenshot" src="img/c2c685ad84fd1dc.png"></p>


      </google-codelab-step>
    
      <google-codelab-step label="Style the data" duration="10">
        <p>The basic map shows our data, but it doesn&#39;t visualize it. Let&#39;s define some of the layer styles so that the data drives the visualization.</p>
<p>We can change the definition of the <code>_solar</code> style so that the size and color of the points reflect the amount of power that each solar panel produces. This replaces the simple style that we defined in the previous step.</p>
<pre><code>    _solar:
        data: {source: solar}
        enabled: true
        _all:
            draw:
                points:
                    collide: false
                    color: |
                        function() {
                            if (feature.Functie == &#39;Wonen&#39;) {
                                return &#39;#FF5306&#39;;
                            } else {
                                return &#39;#FFC12B&#39;;
                            }
                        }
                    size: |
                        function() {
                            var value = +feature.Vermogen;
                            var size = Math.max(value/20000, 3);

                            // If we are zoomed in very far, make the points bigger
                            if ($zoom &gt; 13) {
                               return Math.pow(2, $zoom - 13) * size;
                            }
                            return size;
                        }
</code></pre>
<p>In this YAML file, the <code>size</code> attribute is actually a Javascript function! It is capable of accessing properties in the GeoJSON feature (&#34;vermogen&#34; is Dutch for &#34;capacity&#34;) and of the current map view (<code>$zoom</code>.) The value returned by the function is the size of the point.</p>
<p>Let&#39;s take advantage of our preprocessed neighborhood boundaries, and draw neighborhoods as a chloropleth based on total power generated.</p>
<pre><code>    _neighborhoods:
        enabled: true
        data: {source: neighborhoods}
        draw:
            polygons:
                interactive: true
                order: global.sdk_order_under_water_0
                color: |
                    function() {
                        var value = feature.totalPower;
                        var color = value &gt;= 1267538 ? &#34;rgba(127, 0, 0, 0.5)&#34; :
                                    value &gt;= 1140784.2 ? &#34;rgba(167, 4, 3, 0.5)&#34; :
                                    value &gt;= 1014030.4 ? &#34;rgba(200, 29, 19, 0.5)&#34; :
                                    value &gt;= 887276.6 ? &#34;rgba(224, 69, 48, 0.5)&#34; :
                                    value &gt;= 760522.8 ? &#34;rgba(241, 108, 73, 0.5)&#34; :
                                    value &gt;= 633769 ? &#34;rgba(250, 142, 93, 0.5)&#34; :
                                    value &gt;= 507015.2 ? &#34;rgba(253, 176, 122, 0.5)&#34; :
                                    value &gt;= 380261.4 ? &#34;rgba(253, 202, 148, 0.5)&#34; :
                                    value &gt;= 253507.6 ? &#34;rgba(253, 220, 175, 0.5)&#34; :
                                    value &gt;= 126753.8 ? &#34;rgba(254, 235, 207, 0.5)&#34; :
                                    &#34;rgba(255, 247, 236, 0.3)&#34;;

                        return color

                    }
            lines:
                interactive: true
                order: global.sdk_order_under_roads_0
                color: black
                width: 3px
</code></pre>
<p>Notice that instead of drawing <code>points:</code>, we are now drawing <code>polygons</code> and <code>lines</code>. Here we use the Tangram <code>order</code> property so that the neighborhood boundaries show up underneath roads and water features on the map.</p>
<p>Draw trees with a variable size based on tree trunk diameter.</p>
<pre><code>    _trees:
        enabled: true
        data: {source: trees}
        draw: 
            points:
                collide: false
                color: &#39;#00A000&#39;
                size: |
                    function() {
                        var value = feature.Stamdiameter;
                        var size = value == &#34;0 - 10 cm&#34; ? 1.5 :
                                   value == &#34;11 - 20 cm&#34; ? 2 :
                                   value == &#34;21 - 30 cm&#34; ? 2.5 :
                                   value == &#34;31 - 50 cm&#34; ? 3.25 :
                                   value == &#34;51 - 75 cm&#34; ? 4 :
                                   value == &#34;76 - 100 cm&#34; ? 5 :
                                   1.5;

                        if ($zoom &gt; 13) {
                            return Math.pow(1.5, $zoom - 13) * size;
                        }

                        return size;
                    }
</code></pre>
<p>Let&#39;s add these new style definitions to <code>scene.yaml</code> and take a look. <a href="https://stamen.github.io/here-xyz-demo/solar-tangram/index-step2.html" target="_blank">Now the map is starting to visualize the data.</a></p>
<p><img alt="Map with all layers styled" src="img/5c097e177f8a622f.png"></p>


      </google-codelab-step>
    
      <google-codelab-step label="Adding pop-ups" duration="0">
        <p>In this step, we&#39;ll add a popup that displays the total power generated in a neighborhood when the user hovers over a neighborhood polygon. To do this, we&#39;ll change the Tangram layer definition to include a <code>hover</code> event.</p>
<pre><code>var layer = Tangram.leafletLayer({
    scene: &#39;scene.yaml&#39;,
    attribution: &#39;&lt;a href=&#34;https://mapzen.com/tangram&#34; target=&#34;_blank&#34;&gt;Tangram&lt;/a&gt; | &amp;copy; OSM contributors | &lt;a href=&#34;https://mapzen.com/&#34; target=&#34;_blank&#34;&gt;Mapzen&lt;/a&gt;&#39;,
    events: {
        hover: function(selection) {
            if (mode === &#39;solar&#39;) {
                if (selection.feature) {
                    showPopup(selection.leaflet_event.latlng, selection.feature.properties.Buurtcombinatie, selection.feature.properties.totalPower);
                } else {
                    map.closePopup();
                }
            }
        }
    }
});
</code></pre>
<p>This hover event calls a function that creates a Leaflet popup at the appropriate place on the map. We&#39;ll add the name of the neighborhood and format the numbers so they look nice. This code block can be added to the <code>index.html</code> file directly below the <code>map</code> definition.</p>
<pre><code>function formatNumber(x) {
    return x.toString().replace(/\B(?=(\d{3})+(?!\d))/g, &#34;,&#34;);
}
// popups
var popup = L.popup({closeButton: false});

function showPopup(latlng, name, power) {
    popup
        .setLatLng(latlng)
        .setContent(&#39;&lt;p&gt;&lt;strong&gt;Neighborhood:&lt;/strong&gt; &#39; + name + &#39;&lt;/p&gt;&lt;p&gt;Total Power: &#39; + formatNumber(power) + &#39; kW&lt;/p&gt;&#39;)
        .openOn(map);
}
</code></pre>


      </google-codelab-step>
    
      <google-codelab-step label="Filter the data using a bounding box query" duration="10">
        <p>It could still use a little more interactivity though.</p>
<p>Let&#39;s give the user the ability to draw a rectangle on the screen, and then use this as a bounding box query to the XYZ API. We&#39;re going to use a Leaflet extension called <a href="https://github.com/heyman/leaflet-areaselect/" target="_blank">Leaflet-AreaSelect</a>, which provides a nice user interface for drawing a bounding box. Then we trigger a query to the XYZ API&#39;s <code>bbox</code> endpoint. This XYZ API call takes two latitude and longitude parameters and returns only the points in a space that fall within that bounding box:</p>
<p><code>&#39;https://xyz.api.here.com/hub/spaces/[SpaceID2]/bbox?access_token=[AccessToken]&amp;west=&#39; + west + &#39;&amp;south=&#39; + south + &#39;&amp;east=&#39; + east + &#39;&amp;north=&#39; + north;</code></p>
<p>To calculate the street trees within a particular bounding box, we simply have to get the bounds from <code>Leaflet-AreaSelect</code>, make the API call, and count the number of features returned.</p>
<pre><code>var bounds = this.getBounds();
var spaceID = [SpaceID2];
var accessToken = [AccessToken];
var url = &#39;https://xyz.api.here.com/hub/spaces/&#39; + spaceID + &#39;/bbox?access_token=&#39; + accessToken + &#39;&amp;west=&#39; + bounds.getWest() + &#39;&amp;south=&#39; + bounds.getSouth() + &#39;&amp;east=&#39; + bounds.getEast() + &#39;&amp;north=&#39; + bounds.getNorth();

fetch(url).then((response) =&gt; response.json()).then(function(data) {
    var len = data.features.length;
    // display a nice popup
    L.popup().setLatLng(map.getCenter()).setContent(formatNumber(len) + &#39; trees selected&#39;).openOn(map);
});
</code></pre>
<p>We won&#39;t add this to our code yet though, because we need some way to trigger the <code>Leaflet-AreaSelect</code> first. In the final step, we&#39;ll put everything together.</p>


      </google-codelab-step>
    
      <google-codelab-step label="Putting it all together" duration="10">
        <p>Finally, we&#39;ll add some user interface controls for turning layers off and on. Add the following block to <code>index.html</code> just above the <code>&lt;div id=&#34;container&#34;&gt;</code> block.</p>
<pre><code>&lt;div id=&#34;controls&#34;&gt;
    &lt;div id=&#34;solar&#34; class=&#34;on&#34; onclick=&#34;toggle(&#39;solar&#39;)&#34;&gt;Solar installations&lt;/div&gt;
    &lt;div id=&#34;neighborhoods&#34; class=&#34;on&#34; onclick=&#34;toggle(&#39;neighborhoods&#39;)&#34;&gt;Neighborhoods&lt;/div&gt;
    &lt;div id=&#34;trees&#34; class=&#34;off&#34; onclick=&#34;toggle(&#39;trees&#39;)&#34;&gt;Trees&lt;/div&gt;
    &lt;div id=&#34;counttrees&#34; class=&#34;off&#34; onclick=&#34;countTrees()&#34;&gt;Count trees&lt;/div&gt;
&lt;/div&gt;
</code></pre>
<p>These buttons will trigger a Javascript function that toggles each layer off and on. Add the remainder of the Javascript to the end of the <code>&lt;script&gt;</code> block in <code>index.html</code>.</p>
<pre><code>var mode = &#39;solar&#39;;

function toggle(layerName) {
    layer.scene.config.layers[&#34;_&#34; + layerName].enabled = !layer.scene.config.layers[&#34;_&#34; + layerName].enabled;
    document.getElementById(layerName).className = layer.scene.config.layers[&#34;_&#34; + layerName].enabled ? &#34;on&#34; : &#34;off&#34;;
    layer.scene.updateConfig();
}
</code></pre>
<p>The &#34;count trees&#34; button will trigger a function that adds the bounding box selector to the map and triggers the bounding box query we prototyped earlier.</p>
<pre><code>function countTrees() {
    if (mode === &#39;trees&#39;) {
        areaSelect.remove(); d
        mode = &#39;solar&#39;;
    } else {
        mode = &#39;trees&#39;;
        areaSelect = L.areaSelect({width:200, height:300}); // Need to make a new one each time for some reason
        areaSelect.addTo(map);
        function calcArea(bounds) {
            if (mode == &#39;trees&#39;) { // Prevent this from accidentally running in the other mode
                map.spin(true);
                var spaceID = [SpaceID2];
                var accessToken = [AccessToken];
                var url = &#39;https://xyz.api.here.com/hub/spaces/&#39; + spaceID + &#39;/bbox?access_token=&#39; + accessToken + &#39;&amp;west=&#39; + bounds.getWest() + &#39;&amp;south=&#39; + bounds.getSouth() + &#39;&amp;east=&#39; + bounds.getEast() + &#39;&amp;north=&#39; + bounds.getNorth();
                fetch(url).then((response) =&gt; response.json()).then(function(data) {
                    var len = data.features.length;
                    map.spin(false);
                    L.popup().setLatLng(map.getCenter()).setContent(formatNumber(len) + &#39; trees selected&#39;).openOn(map);
                });
            }
        };
        calcArea(areaSelect.getBounds()); // Run it once at load time
        areaSelect.on(&#34;change&#34;, function() {
            calcArea(this.getBounds());  // Then run it again anytime the box changes
        });
    }
}
</code></pre>
<p>And that&#39;s our <a href="https://stamen.github.io/here-xyz-demo/solar-tangram/" target="_blank">final map</a>!</p>
<p><img alt="Finished Amsterdam solar panels and tree map" src="img/fa42ea027b2d5928.png"></p>


      </google-codelab-step>
    
  </google-codelab>

  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    ga('create', 'UA-49880327-14', 'auto');

    (function() {
      var gaCodelab = '0';
      if (gaCodelab) {
        ga('create', gaCodelab, 'auto', {name: 'codelab'});
      }

      var gaView;
      var parts = location.search.substring(1).split('&');
      for (var i = 0; i < parts.length; i++) {
        var param = parts[i].split('=');
        if (param[0] === 'viewga') {
          gaView = param[1];
          break;
        }
      }
      if (gaView && gaView !== gaCodelab) {
        ga('create', gaView, 'auto', {name: 'view'});
      }
    })();
  </script>

</body>
</html>
